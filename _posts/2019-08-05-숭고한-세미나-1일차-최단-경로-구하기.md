---
layout: post
title: '[숭고한 세미나] 1일차 최단경로 구하기'
author: hoon.sim
comments: true
date: 2019-08-05 16:53
tags: [study,programming,c,cpp,boj]

---

# 최단 경로 구하기

최단 경로 종류

하나의 정점에서 다른 하나의 정점까지의 최단 경로를 구하는 문제

하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제 - 다익스트라

하나의 목적지로 가는 모든 최단 경로를 구하는 문제

모든 최단 경로를 구하는 문제 - 플로이드 와샬

---

### 최단 경로 구하는 방법은 뭐가 있을까?

1. DFS를 이용한 최단 경로 구하기
2. 간선의 길이가 항상 1일때, BFS 이용
3. 행렬곱(?)


### 다익스트라

[출처](https://hsp1116.tistory.com/42)

다익스트라 -> 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제

O(v+(v+e)) //e=v^2

blah,,,blah,,,

~~~c
#include<cstdio>
#include<queue>
#include<vector>
#include<utility>
#define MAX 987654321

using namespace std;
vector < vector < pair < int, int > > > adj;
int n, m, x;
typedef pair < int, int > node;
struct cmp {
	bool operator()(node x, node y) {
		return x.second > y.second;
	}
};
void dijkstra(int x) {
	priority_queue < node, vector<node>, cmp >pq;
	vector < int > dist(n + 1, MAX); dist[x] = 0;
	pq.push(make_pair(x, 0));
	for (int i = 1; i <= n; i++) {
		if (i != x) pq.push(make_pair(i, MAX));
	}
	while (!pq.empty()) {
		int u = pq.top().first;
		int d = pq.top().second; pq.pop();
		if (d > dist[u]) continue;
		for (int i = 0; i < adj[u].size(); i++) {
			int v = adj[u][i].first;
			int w = adj[u][i].second;
			if (dist[v] > dist[u] + w) {
				dist[v] = dist[u] + w;
				pq.push(make_pair(v, dist[v]));
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		printf(dist[i] == MAX ? "INF\n" : "%d\n", dist[i]);
	}
}
int main() {
	scanf("%d %d %d", &n, &m, &x);
	adj.resize(n + 1);
	for (int i = 0; i < m; i++) {
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		adj[u].push_back(make_pair(v, w));
	}
	dijkstra(x);
	return 0;
}
~~~

위의 코드는 [백준 1753](https://www.acmicpc.net/problem/1753)를 푼 문제이다.